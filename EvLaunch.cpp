/*
This Source Code Form is subject to the
terms of the Mozilla Public License, v.
2.0. If a copy of the MPL was not
distributed with this file, You can
obtain one at
http://mozilla.org/MPL/2.0/.
*/

/*
    MaSzyna EU07 locomotive simulator
    Copyright (C) 2001-2004  Marcin Wozniak and others

*/

#include "stdafx.h"
#include "EvLaunch.h"
#include "Globals.h"
#include "Logs.h"
#include "Usefull.h"
#include "McZapkie/mctools.h"
#include "Event.h"
#include "MemCell.h"
#include "mtable.h"
#include "Timer.h"
#include "parser.h"
#include "Console.h"

using namespace Mtable;

//---------------------------------------------------------------------------

TEventLauncher::TEventLauncher()
{ // ustawienie pocz¹tkowych wartoœci dla wszystkich zmiennych
    iKey = 0;
    DeltaTime = -1;
    UpdatedTime = 0;
    fVal1 = fVal2 = 0;
    szText = NULL;
    iHour = iMinute = -1; // takiego czasu nigdy nie bêdzie
    dRadius = 0;
    Event1 = Event2 = NULL;
    MemCell = NULL;
    iCheckMask = 0;
}

TEventLauncher::~TEventLauncher()
{
    SafeDeleteArray(szText);
}

void TEventLauncher::Init()
{
}

bool TEventLauncher::Load(cParser *parser)
{ // wczytanie wyzwalacza zdarzeñ
    std::string token;
    parser->getTokens();
    *parser >> dRadius; // promieñ dzia³ania
    if (dRadius > 0.0)
        dRadius *= dRadius; // do kwadratu, pod warunkiem, ¿e nie jest ujemne
    parser->getTokens(); // klawisz steruj¹cy
    *parser >> token;
    if (token != "none")
    {
        if (token.length() == 1)
            iKey = VkKeyScan(token[1]); // jeden znak jest konwertowany na kod klawisza
        else
            iKey = stol_def(token,0); // a jak wiêcej, to jakby numer klawisza jest
    }
    parser->getTokens();
    *parser >> DeltaTime;
    if (DeltaTime < 0)
        DeltaTime = -DeltaTime; // dla ujemnego zmieniamy na dodatni
    else if (DeltaTime > 0)
    { // wartoœæ dodatnia oznacza wyzwalanie o okreœlonej godzinie
        iMinute = int(DeltaTime) % 100; // minuty s¹ najm³odszymi cyframi dziesietnymi
        iHour = int(DeltaTime - iMinute) / 100; // godzina to setki
        DeltaTime = 0; // bez powtórzeñ
        WriteLog("EventLauncher at " + std::to_string(iHour) + ":" +
                 std::to_string(iMinute)); // wyœwietlenie czasu
    }
    parser->getTokens();
    *parser >> token;
    asEvent1Name = token; // pierwszy event
    parser->getTokens();
    *parser >> token;
    asEvent2Name = token; // drugi event
    if ((asEvent2Name == "end") || (asEvent2Name == "condition"))
    { // drugiego eventu mo¿e nie byæ, bo s¹ z tym problemy, ale ciii...
		token = asEvent2Name; // rozpoznane s³owo idzie do dalszego przetwarzania
        asEvent2Name = "none"; // a drugiego eventu nie ma
    }
    else
    { // gdy s¹ dwa eventy
        parser->getTokens();
        *parser >> token;
        //str = AnsiString(token.c_str());
    }
    if (token == "condition")
    { // obs³uga wyzwalania warunkowego
        parser->getTokens();
        *parser >> token;
		asMemCellName = token;
        parser->getTokens();
        *parser >> token;
        SafeDeleteArray(szText);
        szText = new char[256];
        strcpy(szText, token.c_str());
        if (token.compare("*") != 0) //*=nie braæ command pod uwagê
            iCheckMask |= conditional_memstring;
        parser->getTokens();
        *parser >> token;
        if (token.compare("*") != 0) //*=nie braæ wartoœci 1. pod uwagê
        {
            iCheckMask |= conditional_memval1;
            //str = AnsiString(token.c_str());
            fVal1 = atof(token.c_str());
        }
        else
            fVal1 = 0;
        parser->getTokens();
        *parser >> token;
        if (token.compare("*") != 0) //*=nie braæ wartoœci 2. pod uwagê
        {
            iCheckMask |= conditional_memval2;
            //str = AnsiString(token.c_str());
            fVal2 = atof(token.c_str());
        }
        else
            fVal2 = 0;
        parser->getTokens(); // s³owo zamykaj¹ce
        *parser >> token;
    }
    return true;
};

bool TEventLauncher::Render()
{ //"renderowanie" wyzwalacza
    bool bCond = false;
    if (iKey != 0)
    {
        if (Global::bActive) // tylko jeœli okno jest aktywne
            bCond = (Console::Pressed(iKey)); // czy klawisz wciœniêty
    }
    if (DeltaTime > 0)
    {
        if (UpdatedTime > DeltaTime)
        {
            UpdatedTime = 0; // naliczanie od nowa
            bCond = true;
        }
        else
            UpdatedTime += Timer::GetDeltaTime(); // aktualizacja naliczania czasu
    }
    else
    { // jeœli nie cykliczny, to sprawdziæ czas
        if (GlobalTime->hh == iHour)
        {
            if (GlobalTime->mm == iMinute)
            { // zgodnoœæ czasu uruchomienia
                if (UpdatedTime < 10)
                {
                    UpdatedTime = 20; // czas do kolejnego wyzwolenia?
                    bCond = true;
                }
            }
        }
        else
            UpdatedTime = 1;
    }
    if (bCond) // jeœli spe³niony zosta³ warunek
    {
        if ((iCheckMask != 0) && MemCell) // sprawdzanie warunku na komórce pamiêci
            bCond = MemCell->Compare(szText, fVal1, fVal2, iCheckMask);
    }
    return bCond; // sprawdzanie dRadius w Ground.cpp
}

bool TEventLauncher::IsGlobal()
{ // sprawdzenie, czy jest globalnym wyzwalaczem czasu
    if (DeltaTime == 0)
        if (iHour >= 0)
            if (iMinute >= 0)
                if (dRadius < 0.0) // bez ograniczenia zasiêgu
                    return true;
    return false;
};
//---------------------------------------------------------------------------
